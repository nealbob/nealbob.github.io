---
layout: post
title: Fast Python loops with Cython
excerpt: "My take on the basics of using Cython"
modified: 2014-10-30
tags: [Python, Cython, Machine Learning]
comments: true
---

[Cython](http://cython.org) is essentially a Python to C translator. Given Python like code ---  Python plus type declarations --- Cython generates C code. Cython provides a language almost as simple as Python, but with performance near that of C.  

# Should I use Cython?

If you are working in Python and have a genuine need for performance there are a number of options. First, you can try to exploit fast external packages: for example vectorizing your code via `numpy`. 

However, for many applications we can't escape the need for loops. One option is `numba` a just-in-time compiler for Python, another is give up on Python and learn Julia, see [quantecon](http://quant-econ.net/python_or_julia.html).  

While the static compilation approach of Cython may not be cutting edge, Cython is mature, heavily used and well documented and its capable of handling large complicated projects. Cython code lies behind many of the big Python scientific libraries including `scikit-learn` and `pandas`.

# The example

Our example is evaluating a [Radial Basis Function](http://en.wikipedia.org/wiki/Radial_basis_function) (RBF) approximation scheme. We assume each data point is a 'center' and use Gaussian type RBFs

<div>$$  \hat Y_i = \sum_{j=1}^N\beta_j e^{(-(\theta||X_i - X_j||)^2)} $$</div>

so we need a function which takes an input data array \\( X\\) of shape (N, D), a parameter array \\( \beta\\) of length N and a 'bandwidth' parameter \\(\theta\\) and returns an array of fitted values \\(  \hat Y \\) of length N. 

# Python loops

Here's the naive Python implementation

{% highlight python %}
def rbf_network(X, beta, theta):

    N = X.shape[0]
    D = X.shape[1]
    Y = np.zeros(N)

    for i in range(N):
        for j in range(N):
            r = 0
            for d in range(D):
                r += (X[j, d] - X[i, d]) ** 2
            Y[i] += beta[j] * exp(-(r * theta)**2)

    return Y
{% endhighlight %}

Let's make up some data

{% highlight python %}
import numpy as np
D = 5
N = 1000
X = np.array([np.random.rand(N) for d in range(D)]).T
beta = np.random.rand(N)
theta = 10
{% endhighlight %}

Timing this in `IPython` we get 

{% highlight python %}
%timeit rbf_network(X, beta, theta)
1 loops, best of 3: 10.7 s per loop
{% endhighlight %}

Dam those Python loops are slow!

# scipy.interpolate.Rbf

So in this case we are lucky and there's an external `numpy` based implementation `scipy.interpolate.Rbf` we can try

{% highlight python %}

from scipy.interpolate import Rbf
Xtuple = tuple([X[:, i] for i in range(D)])
rbf = Rbf(X[:,0], X[:,1], X[:,2], X[:,3], X[:, 4], np.random.rand(N))

%timeit rbf(Xtuple)
1 loops, best of 3: 637 ms per loop
{% endhighlight %}

Much better.

# Cython

But what if we want to go faster or we don't have a library we can use. 
