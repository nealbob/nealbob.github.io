---
layout: post
title: Fast Python loops with Cython
excerpt: "My take on the basics of using Cython"
modified: 2014-10-30
tags: [Python, Cython, Machine Learning]
comments: true
---

[Cython](http://cython.org) is essentially a Python to C translator.  Cython allows us to work with a language almost as simple as Python, but still achieve speeds near that of C.  

# Should I use Cython?

If you are working in Python and have a genuine need for performance, you have a few options. First, you can exploit fast external packages: for example vectorizing your code via `numpy`. 

However, for many applications we can't escape the need for loops. One option is `numba` a just-in-time compiler for Python, another is give up on Python and learn Julia, see [quantecon](http://quant-econ.net/python_or_julia.html).  

While the static compilation approach of Cython may not be cutting edge, Cython is mature, heavily used and well documented and its capable of handling large complicated projects. Cython code lies behind many of the big Python scientific libraries including `scikit-learn` and `pandas`.

# The example

Our example is evaluating a [Radial Basis Function](http://en.wikipedia.org/wiki/Radial_basis_function) (RBF) approximation scheme. We assume each data point is a 'center' and use Gaussian type RBFs

<div>$$  \hat Y_i = \sum_{j=1}^N\beta_j e^{(-(\theta||X_i - X_j||)^2)} $$</div>

so we need a function which takes an input data array \\( X\\) of shape (N, D), a parameter array \\( \beta\\) of length N and a 'bandwidth' parameter \\(\theta\\) and returns an array of fitted values \\(  \hat Y \\) of length N. 

# Python loops

Here's the naive Python implementation

{% highlight python %}
from math import exp

def rbf_network(X, beta, theta):

    N = X.shape[0]
    D = X.shape[1]
    Y = np.zeros(N)

    for i in range(N):
        for j in range(N):
            r = 0
            for d in range(D):
                r += (X[j, d] - X[i, d]) ** 2
            Y[i] += beta[j] * exp(-(r * theta)**2)

    return Y
{% endhighlight %}

Let's make up some data

{% highlight python %}
import numpy as np
D = 5
N = 1000
X = np.array([np.random.rand(N) for d in range(D)]).T
beta = np.random.rand(N)
theta = 10
{% endhighlight %}

Timing this in `IPython` we get 

{% highlight python %}
%timeit rbf_network(X, beta, theta)
1 loops, best of 3: 10.7 s per loop
{% endhighlight %}

Dam those Python loops are slow!

# scipy.interpolate.Rbf

So in this case we are lucky and there's an external `numpy` based implementation `scipy.interpolate.Rbf` we can try

{% highlight python %}

from scipy.interpolate import Rbf
rbf = Rbf(X[:,0], X[:,1], X[:,2], X[:,3], X[:, 4], np.random.rand(N))
Xtuple = tuple([X[:, i] for i in range(D)])

%timeit rbf(Xtuple)
1 loops, best of 3: 637 ms per loop
{% endhighlight %}

Much better. But what if we want to go faster or we don't have a library we can use. 

# Cython

A Cython version of our Python function - implemented in the file `fastloop.pyx` - looks something like this

{% highlight cython %}
from math import exp

def rbf_network(double[:, :] X,  double[:] beta, double theta):

    cdef int N = X.shape[0]
    cdef int D = X.shape[1]
    cdef double[:] Y = np.zeros(N)
    cdef int i, j, d
    cdef double r = 0

    for i in range(N):
        for j in range(N):
            r = 0
            for d in range(D):
                r += (X[j, d] - X[i, d]) ** 2
            Y[i] += beta[j] * exp(-(r * theta)**2)

    return Y
{% endhighlight %}

So all we've done here is add some type declarations, `double`, `int` etc. For arrays we use the `memoryview` syntax.  Any code in a `*.pyx` file that you want to be converted to C needs to be typed. So everything inside loops has to be typed (including the indexes). If you leave a variable untyped the code will still compile, but you won't get C speeds.

To compile this file we need a `setup.py` script, that looks something like this

{% highlight python %}

from distutils.core import setup
from Cython.Build import cythonize

setup(name="fastloop", ext_modules=cythonize('fastloop.pyx'),)
{% endhighlight %}

then we compile from the terminal with

{% highlight bash %}
python setup.py build_ext --inplace
{% endhighlight %}

which generates a C code file `fastloop.c` and a compiled Python extension `fastloop.so`. So lets test this out
